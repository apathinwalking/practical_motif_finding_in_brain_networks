%An analysis of the use of graph isomorphism algorithms in the G-Tries algorithm. 
%%Subsection:: Nauty
%%Subsection:: Current results in graph isomorphism
%%Subsection:: Bliss
The proven isomorphism testing toolkit \emph{nauty} is used on two occasions in the \emph{G-Tries} algorithm: in the canonical labeling portion of the construction of the G-Trie, and the testing for automorphisms in the subgraph query portion of the algorithm. As explained in \cite{li12}, A significant portion of the runtime of the \emph{G-Tries} algorithm relies on testing for isomorphism. Although \emph{nauty} is said to run near linear time \rood{cite} on most input graphs, when the number of input graphs itself is \rood{polynomial, exponential?}
For these reasons the current study also analyzed the performance of different canonical labeling and automorphism-testing software in the context which the \emph{G-Tries} algorithm uses \emph{nauty}. First, the algorithm behind \emph{nauty} is described. Next, a review of the current state of isomorphism-testing algorithms is done. And finally, one of the newer graph isomorphism testing algorithms, \emph{bliss}, is described. 
\subsection{Graph Isomorphism Terminology}
A \textit{graph partition} is a set of subsets (called \textit{parts}) of the nodes of a graph $G$ such that no two elements in the same part connect via an edge. A graph partitioning is also called a \textit{coloring} where parts are called \textit{colors}. A partition with total ordering is an \textit{ordered partition}. A \textit{Trivial part} is a part with only 1 node, \textit{discrtete partition} is a partition with only trivial parts, and the \textit{unit partition} is the partition with only one part - which is simply the set of nodes of $G$. A \textit{color-degree vector}\cite{marchetti11} is a vector for a node $x$ in a graph $G$ with an ordered partition $\pi$ whose $i$th element represents the number of neighbors $x$ has in the $i$th part of $\pi$. An orderered partition $\pi$ is \textit{finer} than an ordered partition $\tau$ if every part of $\pi$ is contained in a part of $\tau$ and every earlier part of $\pi$ is contained within an earlier part of $\tau$. An ordered partition $\pi$ is \textit{coarser} than $\tau$ if it is not finer. An \textit{equitable ordered partition} is an ordered partition, $\pi = {V_1, V_2, \dots, V_m}$ such that for every pair of indices $i$ and $j$, there is a non-negative number $b$ such that the part $V_{i}$ shares exactly $b$ neighbors with $V_{j}$.

\subsection{Nauty}
From 1980 up until the last decade, McKay's algorithm for canonical labeling of graphs \cite{mckay81} had been the fastest known canonical labeling algorithm. This algorithm is found in the nauty package released by McKay. As well, it is one of the most popular algorithms for canonical labeling. There are three strands of nauty, as described by \cite{hartke09}. The first uses propogation of degree information from neighboring nodes. The second uses artificial symmetry to build a search tree whose leaves are isomorphic to the graph we are looking at. The third 
looks at automorphisms in the described search tree. 

\textbf{Degree propogation.} In the first part of McKay's algorithm, nodes of our graph are partitioned, and nodes which are in the same part are compared by degree. The algorithm involves finding the \textit{coarsest equitable refinement} of our graph. 
You begin with a graph and an ordered partitioning (specifically the unit partition). Iterate through the parts, starting with the first ordered part, and ending with the last part.For each part, $V_i$ ,check if each node has an identical color-degree vector. If not, further partition $V_i$ to maximal sized parts with the same color-degree vertex in each part. Order said parts by the degree they make with other parts (starting with the smallest), and replace $V_i$ with this ordered partition. Continue with this until you get through all of the parts of your partititon. At this point, you should have an equitable refinement of the graph. Further strands of the algorithm procede to turn this into the coarsest euqitable refinement of the graph. 

\textbf{Search tree.} McKay's algorithm procedes by creating a search tree with our current equitable ordered partition $\pi$ at the root. Thi Ts portion of the algorithm takes up the largest portion of its time complexity\cite{darga04}. The algorithm goes through each part of $\pi$, and splits the part by an arbitrary node. Child nodes of $\pi$ are the resulting equitable ordered partitions. This process is carried out on child nodes until a discrete ordered partition is found. Thus the leaves are discrete ordered partitions. Importantly, search tree nodes also contain the sequence of arbitrary nodes chosen in the splitting process thusfar. Also importantly, each leaf is an isomorph of our original graph $G$. The tree is generated depth-first.

\textbf{Automorphisms.} The final step of the algorithm is pruning the search tree. This step is done during the generation of the search tree. As proved in \cite{mckay81}, if we discover a node $v_2$ which contains an automorphism from $v_1$ (which is already explored) to itselft, we can automatically discard any nodes which would be children of $v2$. automorphism - we can automatically discard any further generated nodes which contain. Further the same can be done for a node which contains a permutation of other nodes, forming an automorphism. 

\section{Other Algorithms for Graph Isomorphism}{
	Below is a brief outline of the different graph isomorphism algorithms which have been developed in the past decade or so. This discussion was cut short due to time constraints, but a full review can be found in \cite{mckay13}. 
	A number of different algorithms which solve the same problem have been developed since 2004, when \emph{saucy} \cite{darga04} was introduced. \emph{saucy} is very similar to the way that \emph{nauty} is written, except that it is optimized on sparse, ordered graphs of the type developed by conjunctive normal form generating algorithms. \emph{saucy} improves upon the nauty algorithm in the partition refinement procedure. Specifically, the number of 
}

%McKay's algorithm is a depth-first search through maximally refined partitions of a graph. 

%Nodes which can be swapped in an automorphism have the same degree, and their neighbors, and neighbor's neighbors have the same degree. If two nodes have differing degree they can not be swapped in an automorphism. 

%Refinement is used to distinguish vertices which cannot map to eachother in an automorphism. Thus we color the vertices based on their degree...
%If a node has a different degree into another part of the partition, then it can be distinguished among nodes in its part. 

%At each step in the search tree generation a vertex is chosen and is given a new color. 

%Search begins with an initial coloring. From the current node, determine the target color-class: the smallest "ordered" partition that is of order greater than 1. Choose an arbitrary node, and make this into a trivial part (singleton color-class). So if we had $\pi$ as a partition, we now have $\pi'$. Put the new color-class at the end of our ordered partition. Now take $\pi'$ and apply the vertex refinement algorithm to it. 

%%Concluding remarks.
As G-Tries can be reused for multiple analysis, the canonical labeling portion may be negligible except in the case of extreme subgraph sizes. The real portion where the G-Tries algorithm is bogged down is in the automorphism testing \cite{li12}. A study of how different algorithms would perform on this portion of the G-Tries algorithm is discussed in the discussion. It optimizes using the fact that sparse graphs have very few connections to other nodes. Thus, in \cite{darga04} they conclude that fewer child nodes be generated in the partition refinement portion of their algorithm. They achieved a significant speedup on sparse graphs in comparison to nauty. This algorithm may be a good choice as a replacement for nauty in the G-Tries algorithm in order to optimize over brain networks, as brain networks are sparse. Another algorithm which is designed for canonical labeling and has recieved large speedups over \emph{nauty} is \emph{bliss} \cite{juntilla07}, which has shown to have better performance on large and sparse graphs over \emph{nauty}.