Before the ReG-Tries algorithm is described, it should be noted that a conceptual error was made in the construction of the algorithm, making it completely unusable for it's intended purpose. Below is a description of the algorithm as it was originally envisioned. A discussion of how to fix the algorithm is described in the discussion section. 
The ReG-Trie algorithm is essentially an extension of Pedro Ribeiro's G-Tries algorithm. It differs, however, in its application. ReG-Trie is designed for the specific use over sets of networks which consist of many of the same connections. More specifically, ReG-Trie was designed to be optimize performance of network motif discovery on weighted networks which have had a range of thresholds applied to them. The algorithm takes advantage of the GTrie structure in order to know the precise outcome on network motif frequencies when an edge is removed.\\
The algorithm uses the exact construction of a G-Trie in Ribeiro's algorithm, the only place where it differs is in the subgraph census step. In the subgraph census, connectional matrices are put in order so that whenever we add a node to our current subgraph, we know exactly where that edges it makes exists on each of the thresholded connectional matrices. The matrices should also be a arranged such that greater thresholded matrices are on the ``bottom'' and less thresholded matrices are on the ``top''. The G-Tries algorithm is run on the ``top'' matrix. Whenever a node is added to our current subgraph, we sequentially poll where each edge occurs on each thresholded matrix. If we meet a matrix which is missing one of the edges we have added on a higher level matrix, we know something about this subgraph, particular to this matrix. The first thing we know is that we do not advance to the same branch which the higher level matrix advances to. If none of the connections from the higher matrix are present, we know that we don't advance at all on the branch. If the higher matrix has advanced to a leaf, we know that that on the lower matrix, and all matrices below that matrix, we do not count this subgraph.\\ 
This is where the conceptual error was made. It had been assumed that knowing a connection is not present means that our lower matrices will not be able to reach a leaf node. This, however, is only the case if we know that a \textit{node} is not present rather than an edge.\\
What this algorithm should have provided was a way for the number of subgraph censuses to be reduced to one for networks which are sequentially derived from eachother by removing edges. Because we would have known that for any missing edge we find, all matrices below the currently-being-checked matrix are also missing that edge, we would have been able to eliminate a number of future computations at least equal to the number of connections removed betwen connections. This however, is surely not the casee. 
